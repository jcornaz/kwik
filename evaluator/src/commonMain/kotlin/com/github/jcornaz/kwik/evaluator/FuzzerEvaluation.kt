package com.github.jcornaz.kwik.evaluator

import com.github.jcornaz.kwik.fuzzer.api.ExperimentalKwikFuzzer
import com.github.jcornaz.kwik.fuzzer.api.Fuzzer
import com.github.jcornaz.kwik.fuzzer.api.simplifier.findSimplestFalsification
import com.github.jcornaz.kwik.generator.api.randomSequence


/**
 * Call multiple times [block] with random values generated by the given [fuzzer]
 *
 * The [block] must perform assertions and throw an exception if the property is falsified.
 * Absence of exception thrown in the [block] means the property is satisfied.
 *
 * @param iterations Number of times [block] should be executed
 * @param seed Random generation seed. Random by default. Specify a value to reproduce consistent results
 * @param block Function invoked multiple times with random inputs to assess a property of the System under test.
 *                 Must return a throw an exception if the property is falsified.
 */
@ExperimentalKwikFuzzer
fun <T> forAny(
    fuzzer: Fuzzer<T>,
    iterations: Int = kwikDefaultIterations,
    seed: Long = nextSeed(),
    block: (T) -> Unit
) {
    require(iterations > 0) { "Iterations must be > 0, but was: $iterations" }

    var iterationDone = 0

    randomSequence(seed) { fuzzer.generate(it) }
        .take(iterations)
        .forEach { tree ->

            try {
                block(tree.item)
            } catch (throwable: Throwable) {
                val simplerInput = tree.findSimplestFalsification {
                    runCatching { block(it) }.isSuccess
                }
                throw FalsifiedPropertyError(iterationDone + 1, iterations, seed, listOf(simplerInput), throwable)
            }

            ++iterationDone
        }
}

private fun <T> MutableList<(T) -> Boolean>.removeSatisfying(input: T) {
    val iterator = listIterator()
    while (iterator.hasNext()) {
        if (iterator.next().invoke(input))
            iterator.remove()
    }
}
